Infrastructure as Code with Terraform

Overview
Terraform is the infrastructure as code offering from HashiCorp. It is a tool for building, changing, and managing infrastructure in a safe, repeatable way. Operators and Infrastructure teams can use Terraform to manage environments with a configuration language called the HashiCorp Configuration Language (HCL) for human-readable, automated deployments.

Infrastructure as code is the process of managing infrastructure in a file or files rather than manually configuring resources in a user interface. A resource in this instance is any piece of infrastructure in a given environment, such as a virtual machine, security group, network interface, etc. At a high level, Terraform allows operators to use HCL to author files containing definitions of their desired resources on almost any provider (AWS, Google Cloud, GitHub, Docker, etc.) and automates the creation of those resources at the time of apply.

A simple workflow for deployment will follow closely to the steps below:

Scope - Confirm what resources need to be created for a given project.
Author - Create the configuration file in HCL based on the scoped parameters.
Initialize - Run terraform init in the project directory with the configuration files. This will download the correct provider plug-ins for the project.
Plan & Apply - Run terraform plan to verify creation process and then terraform apply to create real resources as well as the state file that compares future changes in your configuration files to what actually exists in your deployment environment.

Objectives
In this lab, you will learn how to perform the following tasks:

Build, change, and destroy infrastructure with Terraform
Create Resource Dependencies with Terraform
Provision infrastructure with Terraform

Task 1. Build infrastructure
Terraform comes pre-installed in Cloud Shell. With Terraform already installed, you can dive right in and create some infrastructure.

Start by creating your example configuration to a file named main.tf. Terraform recognizes files ending in .tf or .tf.json as configuration files and will load them when it runs.

Create the main.tf file:
touch main.tf
Copied!
Click the Open Editor button on the toolbar of Cloud Shell. (You can switch between Cloud Shell and the code editor by using the Open Editor and Open Terminal icons as required, or click the Open in new window button to leave the Editor open in a separate tab).

In the Editor, add the following content to the main.tf file.

terraform {
required_providers {
google = {
source = "hashicorp/google"
version = "3.5.0"
}
}
}

provider "google" {

project = "qwiklabs-gcp-03-f65183d10c67"
region = "us-east1"
zone = "us-east1-d"
}

resource "google_compute_network" "vpc_network" {
name = "terraform-network"
}
Copied!
Note: To use this snippet with Terraform 0.12, remove the terraform {} block.
Terraform block
The terraform {} block is required so Terraform knows which provider to download from the Terraform Registry. In the configuration above, the google provider's source is defined as hashicorp/google which is shorthand for registry.terraform.io/hashicorp/google.

You can also assign a version to each provider defined in the required_providers block. The version argument is optional, but recommended. It is used to constrain the provider to a specific version or a range of versions in order to prevent downloading a new provider that may possibly contain breaking changes. If the version isn't specified, Terraform will automatically download the most recent provider during initialization.

To learn more, on the HashiCorp Terraform website, see Provider Requirements.

Providers
The provider block is used to configure the named provider, in this case google. A provider is responsible for creating and managing resources. Multiple provider blocks can exist if a Terraform configuration manages resources from different providers.

Initialization
The first command to run for a new configuration -- or after checking out an existing configuration from version control -- is terraform init, which initializes various local settings and data that will be used by subsequent commands.

Initialize your new Terraform configuration by running the terraform init command in the same directory as your main.tf file:
terraform init
Copied!
Creating resources
Apply you configuration now by running the command terraform apply:
terraform apply
Copied!
The output has a + next to resource "google_compute_network" "vpc_network", meaning that Terraform will create this resource. Beneath that, it shows the attributes that will be set. When the value displayed is (known after apply), it means that the value won't be known until the resource is created.

If the plan was created successfully, Terraform will now pause and wait for approval before proceeding. If anything in the plan seems incorrect or dangerous, it is safe to abort here with no changes made to your infrastructure.

If terraform apply failed with an error, read the error message and fix the error that occurred.

The plan looks acceptable here, so type yes at the confirmation prompt to proceed.
Executing the plan will take a few minutes since Terraform waits for the network to be created successfully:

# ...

Enter a value: yes

google_compute_network.vpc_network: Creating...
google_compute_network.vpc_network: Still creating... [10s elapsed]
google_compute_network.vpc_network: Still creating... [20s elapsed]
google_compute_network.vpc_network: Still creating... [30s elapsed]
google_compute_network.vpc_network: Still creating... [40s elapsed]
google_compute_network.vpc_network: Still creating... [50s elapsed]
google_compute_network.vpc_network: Creation complete after 58s [id=terraform-network]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
After this, Terraform is all done! You can go to the Cloud Console to see the network you have provisioned.

In the Console, from the Navigation menu, navigate to VPC network. You will see the terraform-network has been provisioned.
VPC networks page

In Cloud Shell run the terraform show command to inspect the current state:
terraform show
Copied!
These values can be referenced to configure other resources or outputs, which will be covered later in this lab.

Click Check my progress to verify the objective.
Creating Resources in terraform

Task 2. Change infrastructure
In the previous section, you created basic infrastructure with Terraform: a VPC network. In this section, you're going to modify your configuration, and see how Terraform handles change.

Infrastructure is continuously evolving, and Terraform was built to help manage and enact that change. As you change Terraform configurations, Terraform builds an execution plan that only modifies what is necessary to reach your desired state.

By using Terraform to change infrastructure, you can version control not only your configurations but also your state so you can see how the infrastructure evolves over time.

Adding resources
You can add new resources by adding them to your Terraform configuration and running terraform apply to provision them.

In the Editor, add a compute instance resource to main.tf:
resource "google_compute_instance" "vm_instance" {
name = "terraform-instance"
machine_type = "e2-micro"

boot_disk {
initialize_params {
image = "debian-cloud/debian-11"
}
}

network_interface {
network = google_compute_network.vpc_network.name
access_config {
}
}
}
Copied!
This resource includes a few more arguments. The name and machine type are simple strings, but boot_disk and network_interface are more complex blocks. You can see all of the available options in the google_compute_instance documentation.

For this example, your compute instance will use a Debian operating system, and will be connected to the VPC Network you created earlier. Notice how this configuration refers to the network's name property with google_compute_network.vpc_network.name -- google_compute_network.vpc_network is the ID, matching the values in the block that defines the network, and name is a property of that resource.

The presence of the access_config block, even without any arguments, ensures that the instance will be accessible over the internet.

Now run terraform apply to create the compute instance:
terraform apply
Copied!
Once again, answer yes to the confirmation prompt.
This is a fairly straightforward change - you added a "google_compute_instance" resource named "vm_instance" to your configuration, and Terraform created the resource in Google Cloud.

Changing resources
In addition to creating resources, Terraform can also make changes to those resources.

Add a tags argument to your "vm_instance" so that it looks like this:
resource "google_compute_instance" "vm_instance" {
name = "terraform-instance"
machine_type = "e2-micro"
tags = ["web", "dev"]

# ...

}
Copied!
Run terraform apply again to update the instance:
terraform apply
Copied!
The prefix ~ means that Terraform will update the resource in-place. You can go and apply this change now by responding yes, and Terraform will add the tags to your instance.
Click Check my progress to verify the objective.
Change Infrastructure

Destructive changes
A destructive change is a change that requires the provider to replace the existing resource rather than updating it. This usually happens because the cloud provider doesn't support updating the resource in the way described by your configuration.

Changing the disk image of your instance is one example of a destructive change.

Edit the boot_disk block inside the vm_instance resource in your configuration file and change it to the following:
boot_disk {
initialize_params {
image = "cos-cloud/cos-stable"
}
}
Copied!
Now run terraform apply again to see how Terraform will apply this change to the existing resources:
terraform apply
Copied!
The prefix -/+ means that Terraform will destroy and recreate the resource, rather than updating it in-place. While some attributes can be updated in-place (which are shown with the ~ prefix), changing the boot disk image for an instance requires recreating it. Terraform and the Google Cloud provider handle these details for you, and the execution plan makes it clear what Terraform will do.

Additionally, the execution plan shows that the disk image change is what required your instance to be replaced. Using this information, you can adjust your changes to possibly avoid destroy/create updates if they are not acceptable in some situations.

Once again, Terraform prompts for approval of the execution plan before proceeding. Answer yes to execute the planned steps.
As indicated by the execution plan, Terraform first destroyed the existing instance and then created a new one in its place. You can use terraform show again to see the new values associated with this instance.

Destroy infrastructure
You have now seen how to build and change infrastructure. Before moving on to creating multiple resources and showing resource dependencies, you will see how to completely destroy your Terraform-managed infrastructure.

Destroying your infrastructure is a rare event in production environments. But if you're using Terraform to spin up multiple environments such as development, testing, and staging, then destroying is often a useful action.

Resources can be destroyed using the terraform destroy command, which is similar to terraform apply but it behaves as if all of the resources have been removed from the configuration.

Try the terraform destroy command. Answer yes to execute this plan and destroy the infrastructure:
terraform destroy
Copied!
The - prefix indicates that the instance and the network will be destroyed. As with apply, Terraform shows its execution plan and waits for approval before making any changes.

Just like with terraform apply, Terraform determines the order in which things must be destroyed. Google Cloud won't allow a VPC network to be deleted if there are resources still in it, so Terraform waits until the instance is destroyed before destroying the network. When performing operations, Terraform creates a dependency graph to determine the correct order of operations. In more complicated cases with multiple resources, Terraform will perform operations in parallel when it's safe to do so.

Click Check my progress to verify the objective.
Destructive Changes

Task 3. Create resource dependencies
In this section, you will learn more about resource dependencies and how to use resource parameters to share information about one resource with other resources.

Real-world infrastructure has a diverse set of resources and resource types. Terraform configurations can contain multiple resources, multiple resource types, and these types can even span multiple providers.

In this section, you will be shown a basic example of how to configure multiple resources and how to use resource attributes to configure other resources.

Recreate your network and instance. After you respond to the prompt with yes, the resources will be created:
terraform apply
Copied!
Assigning a static IP address
Now add to your configuration by assigning a static IP to the VM instance in main.tf:
resource "google_compute_address" "vm_static_ip" {
name = "terraform-static-ip"
}
Copied!
This should look familiar from the earlier example of adding a VM instance resource, except this time you're creating a "google_compute_address" resource type. This resource type allocates a reserved IP address to your project.

Next, run terraform plan:
terraform plan
Copied!
You can see what will be created with terraform plan:

$ terraform plan
Refreshing Terraform state in-memory prior to plan...
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.

google_compute_network.vpc_network: Refreshing state... [id=terraform-network]
google_compute_instance.vm_instance: Refreshing state... [id=terraform-instance]

---

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:

- create

Terraform will perform the following actions:

# google_compute_address.vm_static_ip will be created

- resource "google_compute_address" "vm_static_ip" {
  - address = (known after apply)
  - address_type = "EXTERNAL"
  - creation_timestamp = (known after apply)
  - id = (known after apply)
  - name = "terraform-static-ip"
  - network_tier = (known after apply)
  - project = (known after apply)
  - region = (known after apply)
  - self_link = (known after apply)
  - subnetwork = (known after apply)
  - users = (known after apply)
    }

Plan: 1 to add, 0 to change, 0 to destroy.

---

Note: You didn't specify an "-out" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if
"terraform apply" is subsequently run.
Unlike terraform apply, the plan command will only show what would be changed, and never actually apply the changes directly. Notice that the only change you have made so far is to add a static IP. Next, you need to attach the IP address to your instance.

Update the network_interface configuration for your instance like so:
network_interface {
network = google_compute_network.vpc_network.self_link
access_config {
nat_ip = google_compute_address.vm_static_ip.address
}
}
Copied!
The access_config block has several optional arguments, and in this case you'll set nat_ip to be the static IP address. When Terraform reads this configuration, it will:

Ensure that vm_static_ip is created before vm_instance
Save the properties of vm_static_ip in the state
Set nat_ip to the value of the vm_static_ip.address property
Run terraform plan again, but this time, save the plan:
terraform plan -out static_ip
Copied!
Saving the plan this way ensures that you can apply exactly the same plan in the future. If you try to apply the file created by the plan, Terraform will first check to make sure the exact same set of changes will be made before applying the plan.

In this case, you can see that Terraform will create a new google_compute_address and update the existing VM to use it.

Run terraform apply "static_ip" to see how Terraform plans to apply this change:
terraform apply "static_ip"
Copied!
As shown above, Terraform created the static IP before modifying the VM instance. Due to the interpolation expression that passes the IP address to the instance's network interface configuration, Terraform is able to infer a dependency, and knows it must create the static IP before updating the instance.

Click Check my progress to verify the objective.
Create Resource Dependencies

Implicit and explicit dependencies
By studying the resource attributes used in interpolation expressions, Terraform can automatically infer when one resource depends on another. In the example above, the reference to google_compute_address.vm_static_ip.address creates an implicit dependency on the google_compute_address named vm_static_ip.

Terraform uses this dependency information to determine the correct order in which to create and update different resources. In the example above, Terraform knows that the vm_static_ip must be created before the vm_instance is updated to use it.

Implicit dependencies via interpolation expressions are the primary way to inform Terraform about these relationships, and should be used whenever possible.

Sometimes there are dependencies between resources that are not visible to Terraform. The depends_on argument can be added to any resource and accepts a list of resources to create explicit dependencies for.

For example, perhaps an application you will run on your instance expects to use a specific Cloud Storage bucket, but that dependency is configured inside the application code and thus not visible to Terraform. In that case, you can use depends_on to explicitly declare the dependency.

Add a Cloud Storage bucket and an instance with an explicit dependency on the bucket by adding the following to main.tf:

# New resource for the storage bucket our application will use.

resource "google_storage_bucket" "example_bucket" {
name = "<UNIQUE-BUCKET-NAME>"
location = "US"

website {
main_page_suffix = "index.html"
not_found_page = "404.html"
}
}

# Create a new instance that uses the bucket

resource "google_compute_instance" "another_instance" {

# Tells Terraform that this VM instance must be created only after the

# storage bucket has been created.

depends_on = [google_storage_bucket.example_bucket]

name = "terraform-instance-2"
machine_type = "e2-micro"

boot_disk {
initialize_params {
image = "cos-cloud/cos-stable"
}
}

network_interface {
network = google_compute_network.vpc_network.self_link
access_config {
}
}
}
Copied!
Note: Storage buckets must be globally unique. Because of this, you will need to replace UNIQUE-BUCKET-NAME with a unique, valid name for a bucket. Using your name and the date is usually a good way to guess a unique bucket name.
You may wonder where in your configuration these resources should go. The order that resources are defined in a terraform configuration file has no effect on how Terraform applies your changes. Organize your configuration files in a way that makes the most sense for you and your team.

Now run terraform plan and terraform apply to see these changes in action:
terraform plan
terraform apply
Copied!
Click Check my progress to verify the objective.
Create bucket dependent instance

Before moving on, remove these new resources from your configuration and run terraform apply once again to destroy them. You won't use the bucket or the second instance any further in this lab.
Task 4. Provision infrastructure
The compute instance you launched at this point is based on the Google image given, but has no additional software installed or configuration applied.

Google Cloud allows customers to manage their own custom operating system images. This can be a great way to ensure the instances you provision with Terraform are pre-configured based on your needs. Packer is the perfect tool for this and includes a builder for Google Cloud.

Terraform uses provisioners to upload files, run shell scripts, or install and trigger other software like configuration management tools.

Defining a provisioner
To define a provisioner, modify the resource block defining the first vm_instance in your configuration to look like the following:
resource "google_compute_instance" "vm_instance" {
name = "terraform-instance"
machine_type = "e2-micro"
tags = ["web", "dev"]

provisioner "local-exec" {
command = "echo ${google_compute_instance.vm_instance.name}: ${google_compute_instance.vm_instance.network_interface[0].access_config[0].nat_ip} >> ip_address.txt"
}

# ...

}
Copied!
This adds a provisioner block within the resource block. Multiple provisioner blocks can be added to define multiple provisioning steps. Terraform supports many provisioners, but for this example you are using the local-exec provisioner.

The local-exec provisioner executes a command locally on the machine running Terraform, not the VM instance itself. You're using this provisioner versus the others so we don't have to worry about specifying any connection info right now.

This also shows a more complex example of string interpolation than you've seen before. Each VM instance can have multiple network interfaces, so refer to the first one with network_interface[0], count starting from 0, as most programming languages do. Each network interface can have multiple access_config blocks as well, so once again you specify the first one.

Run terraform apply:
terraform apply
Copied!
At this point, the output may be confusing at first.

Terraform found nothing to do - and if you check, you'll find that there's no ip_address.txt file on your local machine.

Terraform treats provisioners differently from other arguments. Provisioners only run when a resource is created, but adding a provisioner does not force that resource to be destroyed and recreated.

Use terraform taint to tell Terraform to recreate the instance:
terraform taint google_compute_instance.vm_instance
Copied!
A tainted resource will be destroyed and recreated during the next apply.

Run terraform apply now:
terraform apply
Copied!
Verify everything worked by looking at the contents of the ip_address.txt file.
It contains the IP address, just as you asked.

Failed provisioners and tainted resources
If a resource is successfully created but fails a provisioning step, Terraform will error and mark the resource as tainted. A resource that is tainted still exists, but shouldn't be considered safe to use, since provisioning failed.

When you generate your next execution plan, Terraform will remove any tainted resources and create new resources, attempting to provision them again after creation.

Destroy provisioners
Provisioners can also be defined that run only during a destroy operation. These are useful for performing system cleanup, extracting data, etc.

For many resources, using built-in cleanup mechanisms is recommended if possible (such as init scripts), but provisioners can be used if necessary.

This lab won't show any destroyed provisioner examples. If you need to use destroy provisioners, please see the Provisioners documentation.

Congratulations!
In this lab, you learned how to build, change, and destroy infrastructure with Terraform. You then created resource dependencies, and provisioned basic infrastructure with Terraform configuration files.

///////////

## Command line output:

student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ cat main.tf
terraform {
required_providers {
google = {
source = "hashicorp/google"
version = "3.5.0"
}
}
}

provider "google" {

project = "qwiklabs-gcp-03-f65183d10c67"
region = "us-east1"
zone = "us-east1-d"
}

resource "google_compute_network" "vpc_network" {
name = "terraform-network"
}

resource "google_compute_instance" "vm_instance" {
name = "terraform-instance"
machine_type = "e2-micro"
tags = ["web", "dev"]
boot_disk {
initialize_params {
image = "cos-cloud/cos-stable"
}
}

network_interface {
network = google_compute_network.vpc_network.self_link
access_config {
nat_ip = google_compute_address.vm_static_ip.address
}
}

}

resource "google_compute_address" "vm_static_ip" {
name = "terraform-static-ip"
}

# New resource for the storage bucket our application will use.

resource "google_storage_bucket" "example_bucket" {
name = "biren23april25"
location = "US"

website {
main_page_suffix = "index.html"
not_found_page = "404.html"
}
}

# Create a new instance that uses the bucket

resource "google_compute_instance" "another_instance" {

# Tells Terraform that this VM instance must be created only after the

# storage bucket has been created.

depends_on = [google_storage_bucket.example_bucket]

name = "terraform-instance-2"
machine_type = "e2-micro"

boot_disk {
initialize_params {
image = "cos-cloud/cos-stable"
}
}

network_interface {
network = google_compute_network.vpc_network.self_link
access_config {
}
}
}

student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ terraform apply
google_compute_address.vm_static_ip: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/regions/us-east1/addresses/terraform-static-ip]
google_compute_network.vpc_network: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/global/networks/terraform-network]
google_compute_instance.vm_instance: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:

- create

Terraform will perform the following actions:

# google_compute_instance.another_instance will be created

- resource "google_compute_instance" "another_instance" {

  - can_ip_forward = false
  - cpu_platform = (known after apply)
  - deletion_protection = false
  - guest_accelerator = (known after apply)
  - id = (known after apply)
  - instance_id = (known after apply)
  - label_fingerprint = (known after apply)
  - machine_type = "e2-micro"
  - metadata_fingerprint = (known after apply)
  - min_cpu_platform = (known after apply)
  - name = "terraform-instance-2"
  - project = (known after apply)
  - self_link = (known after apply)
  - tags_fingerprint = (known after apply)
  - zone = (known after apply)

  - boot_disk {

    - auto_delete = true
    - device_name = (known after apply)
    - disk_encryption_key_sha256 = (known after apply)
    - kms_key_self_link = (known after apply)
    - mode = "READ_WRITE"
    - source = (known after apply)

    - initialize_params { + image = "cos-cloud/cos-stable" + labels = (known after apply) + size = (known after apply) + type = (known after apply)
      }
      }

  - network_interface { + name = (known after apply) + network = "https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-03-f65183d10c67/global/networks/terraform-network" + network_ip = (known after apply) + subnetwork = (known after apply) + subnetwork_project = (known after apply)

          + access_config {
              + nat_ip       = (known after apply)
              + network_tier = (known after apply)
            }
        }

    }

# google_storage_bucket.example_bucket will be created

- resource "google_storage_bucket" "example_bucket" {

  - bucket_policy_only = (known after apply)
  - force_destroy = false
  - id = (known after apply)
  - location = "US"
  - name = "biren23april25"
  - project = (known after apply)
  - self_link = (known after apply)
  - storage_class = "STANDARD"
  - url = (known after apply)

  - website {
    - main_page_suffix = "index.html"
    - not_found_page = "404.html"

}

resource "google_compute_address" "vm_static_ip" {
name = "terraform-static-ip"
}

# New resource for the storage bucket our application will use.

resource "google_storage_bucket" "example_bucket" {
name = "biren23april25"
location = "US"

website {
main_page_suffix = "index.html"
not_found_page = "404.html"
}
}

# Create a new instance that uses the bucket

resource "google_compute_instance" "another_instance" {
}
}
}

Plan: 2 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
Terraform will perform the actions described above.
Only 'yes' will be accepted to approve.

Enter a value: yes

google_storage_bucket.example_bucket: Creating...
google_storage_bucket.example_bucket: Creation complete after 1s [id=biren23april25]
google_compute_instance.another_instance: Creating...
google_compute_instance.another_instance: Still creating... [10s elapsed]
google_compute_instance.another_instance: Creation complete after 18s [id=projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance-2]

Apply complete! Resources: 2 added, 0 changed, 0 destroyed.
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ vim main.tf
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ cat main.tf
terraform {
required_providers {
google = {
source = "hashicorp/google"
version = "3.5.0"
}
}
}

provider "google" {

project = "qwiklabs-gcp-03-f65183d10c67"
region = "us-east1"
zone = "us-east1-d"
}

resource "google_compute_network" "vpc_network" {
name = "terraform-network"
}

resource "google_compute_instance" "vm_instance" {
name = "terraform-instance"
machine_type = "e2-micro"
tags = ["web", "dev"]
boot_disk {
initialize_params {
image = "cos-cloud/cos-stable"
}
}

network_interface {
network = google_compute_network.vpc_network.self_link
access_config {
nat_ip = google_compute_address.vm_static_ip.address
}
}

}

resource "google_compute_address" "vm_static_ip" {
name = "terraform-static-ip"
}

student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ terraform plan
google_compute_network.vpc_network: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/global/networks/terraform-network]
google_compute_address.vm_static_ip: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/regions/us-east1/addresses/terraform-static-ip]
google_storage_bucket.example_bucket: Refreshing state... [id=biren23april25]
google_compute_instance.another_instance: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance-2]
google_compute_instance.vm_instance: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated
with the following symbols:

- destroy

Terraform will perform the following actions:

# google_compute_instance.another_instance will be destroyed

# (because google_compute_instance.another_instance is not in configuration)

- resource "google_compute_instance" "another_instance" {

  - can_ip_forward = false -> null
  - cpu_platform = "Intel Broadwell" -> null
  - deletion_protection = false -> null
  - enable_display = false -> null
  - guest_accelerator = [] -> null
  - id = "projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance-2" -> null
  - instance_id = "334891651244057546" -> null
  - label_fingerprint = "42WmSpB8rSM=" -> null
  - labels = {} -> null
  - machine_type = "e2-micro" -> null
  - metadata = {} -> null
  - metadata_fingerprint = "-KDE5uafeIo=" -> null
  - name = "terraform-instance-2" -> null
  - project = "qwiklabs-gcp-03-f65183d10c67" -> null
  - self_link = "https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance-2" -> null
  - tags = [] -> null
  - tags_fingerprint = "42WmSpB8rSM=" -> null
  - zone = "us-east1-d" -> null

  - boot_disk {

    - auto_delete = true -> null
    - device_name = "persistent-disk-0" -> null
    - mode = "READ_WRITE" -> null
    - source = "https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/disks/terraform-instance-2" -> null

    - initialize_params { - image = "https://www.googleapis.com/compute/v1/projects/cos-cloud/global/images/cos-stable-117-18613-164-121" -> null - labels = {} -> null - size = 10 -> null - type = "pd-standard" -> null
      }
      }

  - network_interface {

    - name = "nic0" -> null
    - network = "https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-03-f65183d10c67/global/networks/terraform-network" -> null
    - network_ip = "10.142.0.3" -> null
    - subnetwork = "https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-03-f65183d10c67/regions/us-east1/subnetworks/terraform-network" -> null
    - subnetwork_project = "qwiklabs-gcp-03-f65183d10c67" -> null

    - access_config { - nat_ip = "35.196.239.184" -> null - network_tier = "PREMIUM" -> null
      }
      }

  - scheduling {

    - automatic_restart = true -> null
    - on_host_maintenance = "MIGRATE" -> null
    - preemptible = false -> null
      }

  - shielded_instance_config { - enable_integrity_monitoring = true -> null - enable_secure_boot = false -> null - enable_vtpm = true -> null
    }
    }

# google_storage_bucket.example_bucket will be destroyed

# (because google_storage_bucket.example_bucket is not in configuration)

- resource "google_storage_bucket" "example_bucket" {

  - bucket_policy_only = false -> null
  - force_destroy = false -> null
  - id = "biren23april25" -> null
  - labels = {} -> null
  - location = "US" -> null
  - name = "biren23april25" -> null
  - project = "qwiklabs-gcp-03-f65183d10c67" -> null
  - requester_pays = false -> null
  - self_link = "https://www.googleapis.com/storage/v1/b/biren23april25" -> null
  - storage_class = "STANDARD" -> null
  - url = "gs://biren23april25" -> null

  - website { - main_page_suffix = "index.html" -> null - not_found_page = "404.html" -> null
    }
    }

Plan: 0 to add, 0 to change, 2 to destroy.

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't guarantee to take exactly these actions
if you run "terraform apply" now.
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ terraform apply
google_compute_address.vm_static_ip: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/regions/us-east1/addresses/terraform-static-ip]
google_compute_network.vpc_network: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/global/networks/terraform-network]
google_compute_instance.another_instance: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance-2]
google_storage_bucket.example_bucket: Refreshing state... [id=biren23april25]
google_compute_instance.vm_instance: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated
with the following symbols:

- destroy

Terraform will perform the following actions:

# google_compute_instance.another_instance will be destroyed

# (because google_compute_instance.another_instance is not in configuration)

- resource "google_compute_instance" "another_instance" {

  - can_ip_forward = false -> null
  - cpu_platform = "Intel Broadwell" -> null
  - deletion_protection = false -> null
  - enable_display = false -> null
  - guest_accelerator = [] -> null
  - id = "projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance-2" -> null
  - instance_id = "334891651244057546" -> null
  - label_fingerprint = "42WmSpB8rSM=" -> null
  - labels = {} -> null
  - machine_type = "e2-micro" -> null
  - metadata = {} -> null
  - metadata_fingerprint = "-KDE5uafeIo=" -> null
  - name = "terraform-instance-2" -> null
  - project = "qwiklabs-gcp-03-f65183d10c67" -> null
  - self_link = "https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance-2" -> null
  - tags = [] -> null
  - tags_fingerprint = "42WmSpB8rSM=" -> null
  - zone = "us-east1-d" -> null

  - boot_disk {

    - auto_delete = true -> null
    - device_name = "persistent-disk-0" -> null
    - mode = "READ_WRITE" -> null
    - source = "https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/disks/terraform-instance-2" -> null

    - initialize_params { - image = "https://www.googleapis.com/compute/v1/projects/cos-cloud/global/images/cos-stable-117-18613-164-121" -> null - labels = {} -> null - size = 10 -> null - type = "pd-standard" -> null
      }
      }

  - network_interface {

    - name = "nic0" -> null
    - network = "https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-03-f65183d10c67/global/networks/terraform-network" -> null
    - network_ip = "10.142.0.3" -> null
    - subnetwork = "https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-03-f65183d10c67/regions/us-east1/subnetworks/terraform-network" -> null
    - subnetwork_project = "qwiklabs-gcp-03-f65183d10c67" -> null

    - access_config { - nat_ip = "35.196.239.184" -> null - network_tier = "PREMIUM" -> null
      }
      }

  - scheduling {

    - automatic_restart = true -> null
    - on_host_maintenance = "MIGRATE" -> null
    - preemptible = false -> null
      }

  - shielded_instance_config { - enable_integrity_monitoring = true -> null - enable_secure_boot = false -> null - enable_vtpm = true -> null
    }
    }

# google_storage_bucket.example_bucket will be destroyed

# (because google_storage_bucket.example_bucket is not in configuration)

- resource "google_storage_bucket" "example_bucket" {

  - bucket_policy_only = false -> null
  - force_destroy = false -> null
  - id = "biren23april25" -> null
  - labels = {} -> null
  - location = "US" -> null
  - name = "biren23april25" -> null
  - project = "qwiklabs-gcp-03-f65183d10c67" -> null
  - requester_pays = false -> null
  - self_link = "https://www.googleapis.com/storage/v1/b/biren23april25" -> null
  - storage_class = "STANDARD" -> null
  - url = "gs://biren23april25" -> null

  - website { - main_page_suffix = "index.html" -> null - not_found_page = "404.html" -> null
    }
    }

Plan: 0 to add, 0 to change, 2 to destroy.

Do you want to perform these actions?
Terraform will perform the actions described above.
terraform {
required_providers {
google = {
source = "hashicorp/google"
version = "3.5.0"
}
}
}

provider "google" {

project = "qwiklabs-gcp-03-f65183d10c67"
region = "us-east1"
zone = "us-east1-d"
}

resource "google_compute_network" "vpc_network" {
Only 'yes' will be accepted to approve.

Enter a value: yes

google_compute_instance.another_instance: Destroying... [id=projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance-2]
google_compute_instance.another_instance: Still destroying... [id=projects/qwiklabs-gcp-03-f65183d10c67/z...east1-d/instances/terraform-instance-2, 10s elapsed]
google_compute_instance.another_instance: Still destroying... [id=projects/qwiklabs-gcp-03-f65183d10c67/z...east1-d/instances/terraform-instance-2, 20s elapsed]
google_compute_instance.another_instance: Still destroying... [id=projects/qwiklabs-gcp-03-f65183d10c67/z...east1-d/instances/terraform-instance-2, 30s elapsed]
google_compute_instance.another_instance: Destruction complete after 34s
google_storage_bucket.example_bucket: Destroying... [id=biren23april25]
google_storage_bucket.example_bucket: Destruction complete after 1s

Apply complete! Resources: 0 added, 0 changed, 2 destroyed.
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ vim main.tf
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ cat main.tf
terraform {
required_providers {
google = {
source = "hashicorp/google"
version = "3.5.0"
}
}
}

provider "google" {

project = "qwiklabs-gcp-03-f65183d10c67"
region = "us-east1"
zone = "us-east1-d"
}

resource "google_compute_network" "vpc_network" {
name = "terraform-network"
}

resource "google_compute_instance" "vm_instance" {
name = "terraform-instance"
machine_type = "e2-micro"
tags = ["web", "dev"]
provisioner "local-exec" {
command = "echo ${google_compute_instance.vm_instance.name}: ${google_compute_instance.vm_instance.network_interface[0].access_config[0].nat_ip} >> ip_address.txt"
}

boot_disk {
initialize_params {
image = "cos-cloud/cos-stable"
}
}

network_interface {
network = google_compute_network.vpc_network.self_link
access_config {
nat_ip = google_compute_address.vm_static_ip.address
}
}

}

resource "google_compute_address" "vm_static_ip" {
name = "terraform-static-ip"
}

student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ terraform apply
google_compute_network.vpc_network: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/global/networks/terraform-network]
google_compute_address.vm_static_ip: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/regions/us-east1/addresses/terraform-static-ip]
google_compute_instance.vm_instance: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance]

No changes. Your infrastructure matches the configuration.

Terraform has compared your real infrastructure against your configuration and found no differences, so no changes
are needed.

Apply complete! Resources: 0 added, 0 changed, 0 destroyed.
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ ls
main.tf README-cloudshell.txt static_ip terraform.tfstate terraform.tfstate.backup
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ terraform taint google_compute_instance.vm_instance
Resource instance google_compute_instance.vm_instance has been marked as tainted.
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ terraform apply
google_compute_network.vpc_network: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/global/networks/terraform-network]
google_compute_address.vm_static_ip: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/regions/us-east1/addresses/terraform-static-ip]
google_compute_instance.vm_instance: Refreshing state... [id=projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated
with the following symbols:
-/+ destroy and then create replacement

Terraform will perform the following actions:

# google_compute_instance.vm_instance is tainted, so must be replaced

-/+ resource "google_compute_instance" "vm_instance" {
~ cpu_platform = "Intel Broadwell" -> (known after apply) - enable_display = false -> null
~ guest_accelerator = [] -> (known after apply)
~ id = "projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance" -> (known after apply)
~ instance_id = "8410608096864724826" -> (known after apply)
~ label_fingerprint = "42WmSpB8rSM=" -> (known after apply) - labels = {} -> null - metadata = {} -> null
~ metadata_fingerprint = "-KDE5uafeIo=" -> (known after apply) + min_cpu_platform = (known after apply)
name = "terraform-instance"
~ project = "qwiklabs-gcp-03-f65183d10c67" -> (known after apply)
~ self_link = "https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance" -> (known after apply)
tags = [
"dev",
"web",
]
~ tags_fingerprint = "XaeQnaHMn9Y=" -> (known after apply)
~ zone = "us-east1-d" -> (known after apply) # (3 unchanged attributes hidden)

      ~ boot_disk {
          ~ device_name                = "persistent-disk-0" -> (known after apply)
          + disk_encryption_key_sha256 = (known after apply)
          + kms_key_self_link          = (known after apply)
          ~ source                     = "https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/disks/terraform-instance" -> (known after apply)
            # (2 unchanged attributes hidden)

          ~ initialize_params {
              ~ image  = "https://www.googleapis.com/compute/v1/projects/cos-cloud/global/images/cos-stable-117-18613-164-121" -> "cos-cloud/cos-stable"
              ~ labels = {} -> (known after apply)
              ~ size   = 10 -> (known after apply)
              ~ type   = "pd-standard" -> (known after apply)
            }
        }

      ~ network_interface {
          ~ name               = "nic0" -> (known after apply)
          ~ network_ip         = "10.142.0.2" -> (known after apply)
          ~ subnetwork         = "https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-03-f65183d10c67/regions/us-east1/subnetworks/terraform-network" -> (known after apply)
          ~ subnetwork_project = "qwiklabs-gcp-03-f65183d10c67" -> (known after apply)
            # (1 unchanged attribute hidden)

          ~ access_config {
              ~ network_tier = "PREMIUM" -> (known after apply)
                # (1 unchanged attribute hidden)
            }
        }

      - scheduling {
          - automatic_restart   = true -> null
          - on_host_maintenance = "MIGRATE" -> null
          - preemptible         = false -> null
        }

      - shielded_instance_config {
          - enable_integrity_monitoring = true -> null
          - enable_secure_boot          = false -> null
          - enable_vtpm                 = true -> null
        }
    }

Plan: 1 to add, 0 to change, 1 to destroy.

Do you want to perform these actions?
Terraform will perform the actions described above.
Only 'yes' will be accepted to approve.

Enter a value: yes

google_compute_instance.vm_instance: Destroying... [id=projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance]
google_compute_instance.vm_instance: Still destroying... [id=projects/qwiklabs-gcp-03-f65183d10c67/z...s-east1-d/instances/terraform-instance, 10s elapsed]
google_compute_instance.vm_instance: Still destroying... [id=projects/qwiklabs-gcp-03-f65183d10c67/z...s-east1-d/instances/terraform-instance, 20s elapsed]
google_compute_instance.vm_instance: Still destroying... [id=projects/qwiklabs-gcp-03-f65183d10c67/z...s-east1-d/instances/terraform-instance, 30s elapsed]
google_compute_instance.vm_instance: Destruction complete after 34s
google_compute_instance.vm_instance: Creating...
google_compute_instance.vm_instance: Still creating... [10s elapsed]
google_compute_instance.vm_instance: Still creating... [20s elapsed]
google_compute_instance.vm_instance: Provisioning with 'local-exec'...
google_compute_instance.vm_instance (local-exec): Executing: ["/bin/sh" "-c" "echo terraform-instance: 35.196.99.44 >> ip_address.txt"]
google_compute_instance.vm_instance: Creation complete after 25s [id=projects/qwiklabs-gcp-03-f65183d10c67/zones/us-east1-d/instances/terraform-instance]

Apply complete! Resources: 1 added, 0 changed, 1 destroyed.
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ ls
ip_address.txt main.tf README-cloudshell.txt static_ip terraform.tfstate terraform.tfstate.backup
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ cat ip_address.txt
terraform-instance: 35.196.99.44
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$
student_04_595806ca4649@cloudshell:~ (qwiklabs-gcp-03-f65183d10c67)$ terraform destroy
