## Task 1. Hello world

---

In Cloud Shell enter the following command to run a hello world container to get started:
docker run hello-world

Run the following command to take a look at the container image it pulled from Docker Hub:
docker images

Run the container again:
docker run hello-world

Finally, look at the running containers by running the following command:
docker ps

In order to see all containers, including ones that have finished executing, run docker ps -a:
docker ps -a

This shows you the Container ID, a UUID generated by Docker to identify the container, and more metadata about the run. The container Names are also randomly generated but can be specified with docker run --name [container-name] hello-world.

## Task 2. Build

In this section, you will build a Docker image that's based on a simple node application.

Execute the following command to create and switch into a folder named test.
mkdir test && cd test
Copied!
Create a Dockerfile:
cat > Dockerfile <<EOF

# Use an official Node runtime as the parent image

FROM node:lts

# Set the working directory in the container to /app

WORKDIR /app

# Copy the current directory contents into the container at /app

ADD . /app

# Make the container's port 80 available to the outside world

EXPOSE 80

# Run app.js using node when the container launches

CMD ["node", "app.js"]
EOF
Copied!
This file instructs the Docker daemon on how to build your image.

The initial line specifies the base parent image, which in this case is the official Docker image for node version long term support (lts).
In the second, you set the working (current) directory of the container.
In the third, you add the current directory's contents (indicated by the "." ) into the container.
Then expose the container's port so it can accept connections on that port and finally run the node command to start the application.
Note: Spend some time reviewing the Dockerfile command references to understand each line of the Dockerfile.
Now you'll write the node application, and after that you'll build the image.

Run the following to create the node application:
cat > app.js << EOF;
const http = require("http");

const hostname = "0.0.0.0";
const port = 80;

const server = http.createServer((req, res) => {
res.statusCode = 200;
res.setHeader("Content-Type", "text/plain");
res.end("Hello World\n");
});

server.listen(port, hostname, () => {
console.log("Server running at http://%s:%s/", hostname, port);
});

process.on("SIGINT", function () {
console.log("Caught interrupt signal and will exit");
process.exit();
});
EOF
Copied!
This is a simple HTTP server that listens on port 80 and returns "Hello World".

Now build the image.

Note again the ".", which means current directory so you need to run this command from within the directory that has the Dockerfile:
docker build -t node-app:0.1 .

Now, run the following command to look at the images you built:
docker images

Task 3. Run
Use this code to run containers based on the image you built:
docker run -p 4000:80 --name my-app node-app:0.1

Open another terminal (in Cloud Shell, click the + icon), and test the server:
curl http://localhost:4000

Close the initial terminal and then run the following command to stop and remove the container:
docker stop my-app && docker rm my-app

Now run the following command to start the container in the background:
docker run -p 4000:80 --name my-app -d node-app:0.1

docker ps

Notice the container is running in the output of docker ps. You can look at the logs by executing docker logs [container_id].
Note: You don't have to write the entire container ID, as long as the initial characters uniquely identify the container. For example, you can execute docker logs 17b if the container ID is 17bcaca6f....
docker logs [container_id]

In your Cloud Shell, open the test directory you created earlier in the lab:
cd test
Copied!
Edit app.js with a text editor of your choice (for example nano or vim) and replace "Hello World" with another string:
....
const server = http.createServer((req, res) => {
res.statusCode = 200;
res.setHeader('Content-Type', 'text/plain');
res.end('Welcome to Cloud\n');
});
....
Copied!
Build this new image and tag it with 0.2:
docker build -t node-app:0.2 .

Run another container with the new image version. Notice how we map the host's port 8080 instead of 80. You can't use host port 4000 because it's already in use.
docker run -p 8080:80 --name my-app-2 -d node-app:0.2
docker ps

Test the containers:
curl http://localhost:8080

And now test the first container you made:
curl http://localhost:4000

## Task 4. Debug

Now that you're familiar with building and running containers, go over some debugging practices.

You can look at the logs of a container using docker logs [container_id]. If you want to follow the log's output as the container is running, use the -f option.
docker logs -f [container_id]

You can use docker exec to do this. Open another terminal (in Cloud Shell, click the + icon) and enter the following command:
docker exec -it [container_id] bash
Copied!
The -it flags let you interact with a container by allocating a pseudo-tty and keeping stdin open. Notice bash ran in the WORKDIR directory (/app) specified in the Dockerfile. From here, you have an interactive shell session inside the container to debug.

ou can examine a container's metadata in Docker by using Docker inspect:
docker inspect [container_id]

Use --format to inspect specific fields from the returned JSON. For example:
docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' [container_id]
Copied!

## Task 5. Publish

Now you're going to push your image to the Google Artifact Registry. After that you'll remove all containers and images to simulate a fresh environment, and then pull and run your containers. This will demonstrate the portability of Docker containers.

To push images to your private registry hosted by Artifact Registry, you need to tag the images with a registry name. The format is <regional-repository>-docker.pkg.dev/my-project/my-repo/my-image.

## Create the target Docker repository (Using Cloud Console)

You must create a repository before you can push any images to it. Pushing an image can't trigger creation of a repository and the Cloud Build service account does not have permissions to create repositories.

From the Navigation Menu, under CI/CD navigate to Artifact Registry > Repositories.

Click the +CREATE REPOSITORY icon next to repositories.

Specify my-repository as the repository name.

Choose Docker as the format.

Under Location Type, select Region and then choose the location : us-west1.

Click Create.

Configure authentication
Before you can push or pull images, configure Docker to use the Google Cloud CLI to authenticate requests to Artifact Registry.

To set up authentication to Docker repositories in the region us-west1, run the following command in Cloud Shell:
gcloud auth configure-docker us-west1-docker.pkg.dev
Copied!
Enter Y when prompted.
The command updates your Docker configuration. You can now connect with Artifact Registry in your Google Cloud project to push and pull images.

Note: Alternately you can use gcloud CLI for a streamlined command-line approach.

## Create an Artifact Registry repository (Using CLI)

Run the following commands to create an Artifact Repository.

gcloud artifacts repositories create my-repository --repository-format=docker --location=us-west1 --description="Docker repository"

Push the container to Artifact Registry
Change into the directory with your Dockerfile.
cd ~/test

Run the command to tag node-app:0.2.
docker build -t us-west1-docker.pkg.dev/qwiklabs-gcp-01-f14b2aeb85a7/my-repository/node-app:0.2 .

Run the following command to check your built Docker images.
docker images

## Push this image to Artifact Registry.

docker push us-west1-docker.pkg.dev/qwiklabs-gcp-01-f14b2aeb85a7/my-repository/node-app:0.2

After the push finishes, from the Navigation Menu, under CI/CD navigate to Artifact Registry > Repositories.

Click on my-repository. You should see your node-app Docker container created:

Test the image
You could start a new VM, ssh into that VM, and install gcloud. For simplicity, just remove all containers and images to simulate a fresh environment.

Stop and remove all containers:
docker stop $(docker ps -q)
docker rm $(docker ps -aq)

You have to remove the child images (of node:lts) before you remove the node image.

Run the following command to remove all of the Docker images.
docker rmi us-west1-docker.pkg.dev/qwiklabs-gcp-01-f14b2aeb85a7/my-repository/node-app:0.2
docker rmi node:lts
docker rmi -f $(docker images -aq) # remove remaining images
docker images

Pull the image and run it.
docker run -p 4000:80 -d us-west1-docker.pkg.dev/qwiklabs-gcp-01-f14b2aeb85a7/my-repository/node-app:0.2

Run a curl against the running container.
curl http://localhost:4000

////////////////////////////

Orchestrating the Cloud with Kubernetes

Google Kubernetes Engine
In the cloud shell environment type the following command to set the zone:
gcloud config set compute/zone us-west1-a

Start up a cluster for use in this lab:
gcloud container clusters create io --zone us-west1-a

You are automatically authenticated to your cluster upon creation. If you lose connection to your Cloud Shell for any reason, run the gcloud container clusters get-credentials io command to re-authenticate.
Note: It will take a while to create a cluster - Kubernetes Engine is provisioning a few Virtual Machines behind the scenes for you to play with!

gcloud container clusters get-credentials io

## Task 1. Get the sample code

To get the code, copy the sample code from a Google Cloud Storage bucket.

In Cloud Shell, copy the source code from the Cloud Shell command line:
gsutil cp -r gs://spls/gsp021/\* .
Copied!
Change into the directory needed for this lab:
cd orchestrate-with-kubernetes/kubernetes
Copied!
List the files to see what you're working with:
ls

## Task 2. A quick Kubernetes demo

The easiest way to get started with Kubernetes is to use the kubectl create command.

Use it to launch a single instance of the nginx container:
kubectl create deployment nginx --image=nginx:1.10.0

Kubernetes has created a Deployment—more about Deployments later, but for now all you need to know is that Deployments keep the Pods up and running even when the nodes they run on fail.

In Kubernetes, all containers run in a Pod.

Use the kubectl get pods command to view the running nginx container:
kubectl get pods

Once the nginx container has a Running status you can expose it outside of Kubernetes using the kubectl expose command:
kubectl expose deployment nginx --port 80 --type LoadBalancer

So what just happened? Behind the scenes Kubernetes created an external load balancer with a public IP address attached to it. Any client who hits that public IP address will be routed to the Pods behind the service. In this case that would be the nginx Pod.

List the services now using the kubectl get services command:
kubectl get services

Note: It may take a few seconds before the ExternalIP field is populated for your service. This is normal—just re-run the kubectl get services command every few seconds until the field populates.
Add the External IP to this command to hit the Nginx container remotely:
curl http://<External IP>:80

And there you go! Kubernetes supports an easy to use workflow out of the box using the kubectl run and expose commands.

## Task 3. About Pods

At the core of Kubernetes is the Pod.

Pods represent and hold a collection of one or more containers. Generally, if you have multiple containers with a hard dependency on each other, you package the containers inside a single Pod.

The following example shows a Pod that contains the monolith and nginx containers.

Pod containing the monolith and nginx containers

Pods also have Volumes. Volumes are data disks that live as long as the Pods live, and can be used by the containers in that Pod. Pods provide a shared namespace for their contents which means that the two containers inside of our example Pod can communicate with each other, and they also share the attached volumes.

Pods also share a network namespace. This means that there is one IP Address per Pod.

Next, a deeper dive into Pods.

## Task 4. Create Pods

Pods can be created using Pod configuration files. Take a moment to explore the monolith Pod configuration file.

Go to the directory:
cd ~/orchestrate-with-kubernetes/kubernetes

Run the following to view a configuration file:
cat pods/monolith.yaml

There's a few things to notice here:

Your Pod is made up of one container (the monolith).
You're passing a few arguments to the container when it starts.
You're opening port 80 for http traffic.
Create the monolith Pod using kubectl:
kubectl create -f pods/monolith.yaml

Examine your Pods. Use the kubectl get pods command to list all Pods running in the default namespace:
kubectl get pods

Note: It may take a few seconds before the monolith Pod is up and running. The monolith container image needs to be pulled from the Docker Hub before you can run it.
Once the Pod is running, use the kubectl describe command to get more information about the monolith Pod:
kubectl describe pods monolith
Copied!
You see a lot of the information about the monolith Pod, including the Pod IP address and the event log. This information comes in handy when troubleshooting.

Kubernetes makes it easy to create Pods by describing them in configuration files, and then view information about them when they are running. At this point you have the ability to create all the Pods your Deployment requires!

## Task 5. Interact with Pods

By default, Pods are allocated a private IP address and cannot be reached outside the cluster. Use the kubectl port-forward command to map a local port to a port inside the monolith Pod.

Note: From this point on, this lab will ask you to work in multiple cloud shell tabs to set up communication between the Pods. Any commands that are executed in a second or third command shell will be denoted in the command's instructions.
Open a second Cloud Shell terminal. Now you have two terminals, one to run the kubectl port-forward command, and the other to issue curl commands.

In the 2nd terminal, run this command to set up port-forwarding:

kubectl port-forward monolith 10080:80
Copied!
Now in the 1st terminal start talking to your Pod using curl:
curl http://127.0.0.1:10080
Copied!
Yes! You got a friendly "hello" back from your container.

Now use the curl command to see what happens when you hit a secure endpoint:
curl http://127.0.0.1:10080/secure
Copied!
Uh oh.

To get an auth token back from the monolith, try logging in:
curl -u user http://127.0.0.1:10080/login
Copied!
At the login prompt, use the super-secret password password to login.
Logging in caused a JWT token to print out.

Since Cloud Shell does not handle copying long strings well, create an environment variable for the token.
TOKEN=$(curl http://127.0.0.1:10080/login -u user|jq -r '.token')
Copied!
Enter the super-secret password password again when prompted for the host password.

Use this command to copy and then use the token to hit the secure endpoint with curl:

curl -H "Authorization: Bearer $TOKEN" http://127.0.0.1:10080/secure
Copied!
At this point you should get a response back from the application, letting you know everything is right in the world again.

Use the kubectl logs command to view the logs for the monolith Pod.
kubectl logs monolith
Copied!
Open a 3rd terminal and use the -f flag to get a stream of the logs happening in real-time:
kubectl logs -f monolith
Copied!
Now if you use curl in the 1st terminal to interact with the monolith, you can see the logs updating (in the 3rd terminal):
curl http://127.0.0.1:10080
Copied!
Use the kubectl exec command to run an interactive shell inside the monolith Pod. This comes in handy when you want to troubleshoot from within a container:
kubectl exec monolith --stdin --tty -c monolith -- /bin/sh
Copied!
For example, once you have a shell into the monolith container you can test external connectivity using the ping command:
ping -c 3 google.com
Copied!
Be sure to log out when you're done with this interactive shell.
exit
Copied!
As you can see, interacting with Pods is as easy as using the kubectl command. If you need to hit a container remotely, or get a login shell, Kubernetes provides everything you need to get up and going.

## Task 6. About Services

Pods aren't meant to be persistent. They can be stopped or started for many reasons, like failed liveness or readiness checks, which leads to a problem:

Services are the persistent end point for the pods.

What happens if you want to communicate with a set of Pods? When they get restarted they might have a different IP address.

That's where Services come in. Services provide stable endpoints for Pods.

Services use labels to determine what Pods they operate on. If Pods have the correct labels, they are automatically picked up and exposed by our services.

The level of access a service provides to a set of Pods depends on the Service's type. Currently there are three types:

ClusterIP (internal) is the default type. This Service is only visible inside the cluster.
NodePort gives each node in the cluster an externally accessible IP.
LoadBalancer adds a load balancer from the cloud provider which forwards traffic from the Service to Nodes within it.

kubectl create secret generic tls-certs --from-file tls/
kubectl create configmap nginx-proxy-conf --from-file nginx/proxy.conf
kubectl create -f pods/secure-monolith.yaml

kubectl create -f services/monolith.yaml

gcloud compute firewall-rules create allow-monolith-nodeport \
 --allow=tcp:31000

## Deployment:

The Deployment creates 1 replica, and you're using version 2.0.0 of the auth container.

When you run the kubectl create command to create the auth Deployment it will make one Pod that conforms to the data in the Deployment manifest. This means you can scale the number of Pods by changing the number specified in the Replicas field.

Deployment, drive current state towards desired state

Anyway, go ahead and create your Deployment object:
kubectl create -f deployments/auth.yaml

It's time to create a service for your auth Deployment. Use the kubectl create command to create the auth service:
kubectl create -f services/auth.yaml

Do the same thing to create and expose the hello Deployment:
kubectl create -f deployments/hello.yaml
kubectl create -f services/hello.yaml

And one more time to create and expose the frontend Deployment.
kubectl create configmap nginx-frontend-conf --from-file=nginx/frontend.conf
kubectl create -f deployments/frontend.yaml
kubectl create -f services/frontend.yaml

Note: There is one more step to creating the frontend because you need to store some configuration data with the container.
Interact with the frontend by grabbing its External IP and then curling to it:
kubectl get services frontend

Note: It might take a minute for the external IP address to be generated. Run the above command again if the EXTERNAL-IP column status is pending.
curl -k https://<EXTERNAL-IP>

And you get a hello response back!

## Challenge Lab:

You are expected to create container images, store the images in a repository, and expose a deployment in Kubernetes. Your know that Kurt, your supervisor, will ask you to complete these tasks:

Create a Docker image and store the Dockerfile.
Test the created Docker image.
Push the Docker image into the Artifact Registry.
Use the image to create and expose a deployment in Kubernetes

source <(gsutil cat gs://cloud-training/gsp318/marking/setup_marking_v2.sh)

gsutil cp gs://spls/gsp318/valkyrie-app.tgz .
tar -xzf valkyrie-app.tgz
cd valkyrie-app

Task1:

Use valkyrie-app/Dockerfile to create a Docker image called valkyrie-app with the tag v0.0.1.

docker build -t us-west1-docker.pkg.dev/qwiklabs-gcp-01-f14b2aeb85a7/my-repository/node-app:0.2 .

docker build -t valkyrie-app:v0.0.1 .

docker build -t valkyrie-prod:v0.0.3 -f source/Dockerfile .

docker run --name valkyrie-container -d -p 8080:8080 valkyrie-prod:v0.0.3

authenticate registery:

gcloud auth configure-docker us-east1-docker.pkg.dev

docker tag valkyrie-prod:v0.0.3 us-east1-docker.pkg.dev/qwiklabs-gcp-01-cf31b282965f/valkyrie-repository/valkyrie-prod:v0.0.3

push to Registry

docker push us-east1-docker.pkg.dev/qwiklabs-gcp-01-cf31b282965f/valkyrie-repository/valkyrie-prod:v0.0.3

gcloud container clusters get-credentials <CLUSTER_NAME> --zone us-east1-c --project <PROJECT_ID>

gcloud container clusters get-credentials valkyrie-dev --zone us-east1-c --project qwiklabs-gcp-01-cf31b282965f

kubectl apply -f deployment.yaml
kubectl apply -f service.yaml

kubectl get deployment
kubectl get svc

Task2:
Launch a container using the image valkyrie-app:v0.0.1.
You need to map the host’s port 8080 to port 8080 on the container.
Add & to the end of the command to cause the container to run in the background.

Now run the following command to start the container in the background:
docker run -p 8080:8080 --name valkyrie-app valkyrie-app:v0.0.1 &

Task 3. Push the Docker image to the Artifact Registry

Create a repository named valkyrie-repository in Artifact Registry. Use Docker as the format and use the us-east1 region as the location.

Before you can push or pull images, configure Docker to use the Google Cloud CLI to authenticate requests to Artifact Registry. You will need to set up authentication to Docker repositories. You can use the following command.

gcloud auth configure-docker us-east1-docker.pkg.dev

Re-tag the container to be able push it to the repository. The format should resemble the following: LOCATION-docker.pkg.dev/PROJECT-ID/REPOSITORY/IMAGE.
Push the Docker image to the Artifact Registry.

Run the command to tag node-app:0.2.
docker build -t us-west1-docker.pkg.dev/qwiklabs-gcp-01-f14b2aeb85a7/my-repository/node-app:0.2 .

docker push us-west1-docker.pkg.dev/qwiklabs-gcp-01-f14b2aeb85a7/my-repository/node-app:0.2

## Retag and push to artifactory:

docker build -t us-east1-docker.pkg.dev/qwiklabs-gcp-00-65cd0dadce91/valkyrie-repository/alkyrie-app:v0.0.2 .

docker push us-east1-docker.pkg.dev/qwiklabs-gcp-00-65cd0dadce91/valkyrie-repository/alkyrie-app:v0.0.2

Task 4. Create and expose a deployment in Kubernetes

Kurt created the deployment.yaml and service.yaml to deploy your new container image to a Kubernetes cluster (called valkyrie-dev). The two files are in valkyrie-app/k8s.

Get the Kubernetes credentials using us-east1-d zone before you deploy the image onto the Kubernetes cluster.

Before you create the deployments, Make sure you check and replace some placeholder values in the deployment.yaml file and the format should be LOCATION-docker.pkg.dev/PROJECT-ID/REPOSITORY/IMAGE.

Create the deployments from the deployment.yaml and service.yaml files.

From the Navigation Menu, select Kubernetes Engine > Gateways, Services & Ingress. Click on the load balancer IP Address of the valkyrie-dev service to verify your services are up and running

gcloud config set compute/zone us-east1-d

Start up a cluster for use in this lab:
gcloud container clusters create valkyrie-dev --zone us-east1-d -- already exists
gcloud container clusters get-credentials valkyrie-dev

gcloud container clusters get-credentials valkyrie-dev
Fetching cluster endpoint and auth data.
kubeconfig entry generated for valkyrie-dev.

Edit deployment and service yaml file for below image:

IMAGE:
us-east1-docker.pkg.dev/qwiklabs-gcp-00-65cd0dadce91/valkyrie-repository/valkyrie-app:v0.0.2

kubectl create -f deployment.yaml
kubectl create -f service.yaml

kubectl expose deployment valkyrie-dev --port 80 --type LoadBalancer

Lab command:

student_00_aafcd0891006@cloudshell:~ (qwiklabs-gcp-01-cf31b282965f)$ source <(gsutil cat gs://cloud-training/gsp318/marking/setup_marking_v2.sh)
Copying gs://cloud-training/gsp318/marking/step1_v2.sh...
Copying gs://cloud-training/gsp318/marking/step2_v2.sh...

- [2 files][ 1.2 KiB/ 1.2 KiB]  
  Operation completed over 2 objects/1.2 KiB.  
  student_00_aafcd0891006@cloudshell:~/marking (qwiklabs-gcp-01-cf31b282965f)$ ls
  step1_v2.sh step2_v2.sh
  student_00_aafcd0891006@cloudshell:~/marking (qwiklabs-gcp-01-cf31b282965f)$
  student_00_aafcd0891006@cloudshell:~/marking (qwiklabs-gcp-01-cf31b282965f)$ gsutil cp gs://spls/gsp318/valkyrie-app.tgz .
  Copying gs://spls/gsp318/valkyrie-app.tgz...
  / [1 files][ 20.4 KiB/ 20.4 KiB]  
  Operation completed over 1 objects/20.4 KiB. a  
  student_00_aafcd0891006@cloudshell:~/marking (qwiklabs-gcp-01-cf31b282965f)$ ls
  step1_v2.sh step2_v2.sh valkyrie-app.tgz
  student_00_aafcd0891006@cloudshell:~/marking (qwiklabs-gcp-01-cf31b282965f)$ tar -xzf valkyrie-app.tgz
  cd valkyrie-app
  FROM golang:1.10
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ pwd
  /home/student_00_aafcd0891006/marking/valkyrie-app
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ ls
  Jenkinsfile k8s source
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ cd source/
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$ ls
  Gopkg.lock Gopkg.toml html.go main.go main_test.go vendor
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$ pwd
  /home/student_00_aafcd0891006/marking/valkyrie-app/source
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$ vi Dockerfile
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$ cat Dockerfile
  FROM golang:1.10
  WORKDIR /go/src/app
  COPY source .
  RUN go install -v
  ENTRYPOINT ["app","-single=true","-port=8080"]
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$
  student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$ docker build -t valkyrie-prod:v0.0.3 .
  [+] Building 3.0s (7/8) docker:default
  => [internal] load build definition from Dockerfile 0.0s
  => => transferring dockerfile: 153B 0.0s
  => [internal] load metadata for docker.io/library/golang:1.10 2.7s
  => [internal] load .dockerignore 0.0s
  => => transferring context: 2B 0.0s
  => CANCELED [1/4] FROM docker.io/library/golang:1.10@sha256:6d5e79878a3e4f1b30b7aa4d24fb6ee6184e905a9b172fc72593935633be4c46 0.1s
  => => resolve docker.io/library/golang:1.10@sha256:6d5e79878a3e4f1b30b7aa4d24fb6ee6184e905a9b172fc72593935633be4c46 0.0s
  => => sha256:6d5e79878a3e4f1b30b7aa4d24fb6ee6184e905a9b172fc72593935633be4c46 3.46kB / 3.46kB 0.0s
  => => sha256:eac40ba14416262e26def90a2d6f10d6ff579ea61c267963f6cbfbbe63b0ea7b 1.80kB / 1.80kB 0.0s
  => => sha256:6fd1f7edb6ab06a00b9d8a68836202042694651c5963f463afca8b76a693e099 5.47kB / 5.47kB 0.0s
  => [internal] load build context 0.0s
  => => transferring context: 2B 0.0s
  => CACHED [2/4] WORKDIR /go/src/app 0.0s
  => ERROR [3/4] COPY source . 0.0s

---

> [3/4] COPY source .:

---

## Dockerfile:3

1 | FROM golang:1.10
2 | WORKDIR /go/src/app
3 | >>> COPY source .
4 | RUN go install -v
5 | ENTRYPOINT ["app","-single=true","-port=8080"]

---

ERROR: failed to solve: failed to compute cache key: failed to calculate checksum of ref 15289ed8-8dff-41e5-8dcf-613f930b8f56::gb55uttuqelqn3o7x77c0doc9: "/source": not found
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$ cd ..
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ cd -
/home/student_00_aafcd0891006/marking/valkyrie-app/source
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$ ls
Dockerfile Gopkg.lock Gopkg.toml html.go main.go main_test.go vendor
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/source (qwiklabs-gcp-01-cf31b282965f)$ cd ..
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker build -t valkyrie-prod:v0.0.3 source/Dockerfile
[+] Building 0.0s (0/0) docker:default
ERROR: unable to prepare context: path "source/Dockerfile" not found
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ ls
Jenkinsfile k8s source
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker build -t valkyrie-prod:v0.0.3 -f source/Dockerfile source/
[+] Building 0.9s (7/8) docker:default
=> [internal] load build definition from Dockerfile 0.0s
=> => transferring dockerfile: 153B 0.0s
=> [internal] load metadata for docker.io/library/golang:1.10 0.7s
=> [internal] load .dockerignore 0.0s
=> => transferring context: 2B 0.0s
=> CANCELED [1/4] FROM docker.io/library/golang:1.10@sha256:6d5e79878a3e4f1b30b7aa4d24fb6ee6184e905a9b172fc72593935633be4c46 0.1s
=> => resolve docker.io/library/golang:1.10@sha256:6d5e79878a3e4f1b30b7aa4d24fb6ee6184e905a9b172fc72593935633be4c46 0.0s
=> => sha256:6d5e79878a3e4f1b30b7aa4d24fb6ee6184e905a9b172fc72593935633be4c46 3.46kB / 3.46kB 0.0s
=> => sha256:eac40ba14416262e26def90a2d6f10d6ff579ea61c267963f6cbfbbe63b0ea7b 1.80kB / 1.80kB 0.0s
=> => sha256:6fd1f7edb6ab06a00b9d8a68836202042694651c5963f463afca8b76a693e099 5.47kB / 5.47kB 0.0s
=> [internal] load build context 0.0s
=> => transferring context: 2B 0.0s
=> CACHED [2/4] WORKDIR /go/src/app 0.0s
=> ERROR [3/4] COPY source . 0.0s

---

> [3/4] COPY source .:

---

## Dockerfile:3

1 | FROM golang:1.10
2 | WORKDIR /go/src/app
3 | >>> COPY source .
4 | RUN go install -v
5 | ENTRYPOINT ["app","-single=true","-port=8080"]

---

ERROR: failed to solve: failed to compute cache key: failed to calculate checksum of ref 15289ed8-8dff-41e5-8dcf-613f930b8f56::yve8da0yc4j44a6k4sc74dane: "/source": not found
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ ls
Jenkinsfile k8s source
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ ls
Jenkinsfile k8s source
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker build -t valkyrie-prod:v0.0.3 -f source/Dockerfile .
[+] Building 31.5s (9/9) FINISHED docker:default
=> [internal] load build definition from Dockerfile 0.0s
=> => transferring dockerfile: 153B 0.0s
=> [internal] load metadata for docker.io/library/golang:1.10 0.8s
=> [internal] load .dockerignore 0.0s
=> => transferring context: 2B 0.0s
=> [1/4] FROM docker.io/library/golang:1.10@sha256:6d5e79878a3e4f1b30b7aa4d24fb6ee6184e905a9b172fc72593935633be4c46 24.1s
=> => resolve docker.io/library/golang:1.10@sha256:6d5e79878a3e4f1b30b7aa4d24fb6ee6184e905a9b172fc72593935633be4c46 0.0s
=> => sha256:34d8874714d74b636739b8a52204650a664fca8ff9741dd66810f30196f103e2 10.78MB / 10.78MB 0.8s
=> => sha256:eac40ba14416262e26def90a2d6f10d6ff579ea61c267963f6cbfbbe63b0ea7b 1.80kB / 1.80kB 0.0s
=> => sha256:6fd1f7edb6ab06a00b9d8a68836202042694651c5963f463afca8b76a693e099 5.47kB / 5.47kB 0.0s
=> => sha256:741437d97401b83849ccbfe4ed8964049b752081647d7f1ea8aea29d989f8968 45.34MB / 45.34MB 0.7s
=> => sha256:0a108aa2667933b852b8d003f97b344d014fcd7e06a0c0e6e04f2d6906738388 4.34MB / 4.34MB 0.6s
=> => sha256:6d5e79878a3e4f1b30b7aa4d24fb6ee6184e905a9b172fc72593935633be4c46 3.46kB / 3.46kB 0.0s
=> => sha256:7f0334c36886bd4619e8d05ccf68003e53b0b6098b2166a216bd009dba678ed8 50.06MB / 50.06MB 1.5s
=> => extracting sha256:741437d97401b83849ccbfe4ed8964049b752081647d7f1ea8aea29d989f8968 4.1s
=> => sha256:d35724ed4672cc1ac62dca685634f02297e306fd1920dd76996799c00b728cbb 57.62MB / 57.62MB 1.9s
=> => sha256:c0eaf021aeaf304faaa8b6cb5a967532e83d0c9af364ab091bb947943e31c874 102.19MB / 102.19MB 2.8s
=> => sha256:d3d9c96611f1f779cd0bf0d343ff910d5bc1aafb180b4e3aac7190db8269a829 126B / 126B 1.9s
=> => extracting sha256:34d8874714d74b636739b8a52204650a664fca8ff9741dd66810f30196f103e2 1.0s
=> => extracting sha256:0a108aa2667933b852b8d003f97b344d014fcd7e06a0c0e6e04f2d6906738388 0.2s
=> => extracting sha256:7f0334c36886bd4619e8d05ccf68003e53b0b6098b2166a216bd009dba678ed8 4.8s
=> => extracting sha256:d35724ed4672cc1ac62dca685634f02297e306fd1920dd76996799c00b728cbb 4.5s
=> => extracting sha256:c0eaf021aeaf304faaa8b6cb5a967532e83d0c9af364ab091bb947943e31c874 7.8s
=> => extracting sha256:d3d9c96611f1f779cd0bf0d343ff910d5bc1aafb180b4e3aac7190db8269a829 0.0s
=> [internal] load build context 0.0s
=> => transferring context: 67.54kB 0.0s
=> [2/4] WORKDIR /go/src/app 4.3s
=> [3/4] COPY source . 0.0s
=> [4/4] RUN go install -v 2.0s
=> exporting to image 0.2s
=> => exporting layers 0.1s
=> => writing image sha256:f4b3cf5519d6cbd50819e414c8592b212c7b434225fee6bdee54b51557512f93 0.0s
=> => naming to docker.io/library/valkyrie-prod:v0.0.3 0.0s
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ ls
Jenkinsfile k8s source
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ bash ~/marking/step1_v2.sh
Image exists
Go ahead and check the activity tracking on the lab page
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker run --name valkyrie-container -d valkyrie-prod:v0.0.3
a4503103827aa3d5aa42cc502069da50ad3b7904a49f99e43ca3e513365e0788
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ bash ~/marking/step2_v2.sh
The container is running, but the website is not published on port 8080
Did you publish port 8080 to port 8080?
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
a4503103827a valkyrie-prod:v0.0.3 "app -single=true -p…" About a minute ago Up About a minute valkyrie-container
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker run --name valkyrie-container -d -p 8080:8080 valkyrie-prod:v0.0.3
docker: Error response from daemon: Conflict. The container name "/valkyrie-container" is already in use by container "a4503103827aa3d5aa42cc502069da50ad3b7904a49f99e43ca3e513365e0788". You have to remove (or rename) that container to be able to reuse that name.

Run 'docker run --help' for more information
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
a4503103827a valkyrie-prod:v0.0.3 "app -single=true -p…" 2 minutes ago Up 2 minutes valkyrie-container
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker stop a450
a450
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker rm a450
a450
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker run --name valkyrie-container -d -p 8080:8080 valkyrie-prod:v0.0.3
68d32c1b90135a8b284eda993376205c8c2d8736993c70422b418f15ebbc7372
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
68d32c1b9013 valkyrie-prod:v0.0.3 "app -single=true -p…" 5 seconds ago Up 4 seconds 0.0.0.0:8080->8080/tcp valkyrie-container
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ bash ~/marking/step2_v2.sh
Container running and visible on port 8080, good job!
Go ahead and check the activity tracking on the lab page
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ gcloud artifacts repositories create valkyrie-repository --repository-format=docker --location=us-east1 --description="Docker repository"
Create request issued for: [valkyrie-repository]
Waiting for operation [projects/qwiklabs-gcp-01-cf31b282965f/locations/us-east1/operations/02e411cc-f7f4-484d-bf71-d99cd5508b7f] to complete...working.
..  
Waiting for operation [projects/qwiklabs-gcp-01-cf31b282965f/locations/us-east1/operations/02e411cc-f7f4-484d-bf71-d99cd5508b7f] to complete...working.
..  
Waiting for operation [projects/qwiklabs-gcp-01-cf31b282965f/locations/us-east1/operations/02e411cc-f7f4-484d-bf71-d99cd5508b7f] to complete...working.
..  
Waiting for operation [projects/qwiklabs-gcp-01-cf31b282965f/locations/us-east1/operations/02e411cc-f7f4-484d-bf71-d99cd5508b7f] to complete...working
Waiting for operation [projects/qwiklabs-gcp-01-cf31b282965f/locations/us-east1/operations/02e411cc-f7f4-484d-bf71-d99cd5508b7f] to complete...done.  
Created repository [valkyrie-repository].
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ gcloud auth configure-docker us-east1-docker.pkg.dev
WARNING: Your config file at [/home/student_00_aafcd0891006/.docker/config.json] contains these credential helper entries:

{
"credHelpers": {
"gcr.io": "gcloud",
"us.gcr.io": "gcloud",
"eu.gcr.io": "gcloud",
"asia.gcr.io": "gcloud",
"staging-k8s.gcr.io": "gcloud",
"marketplace.gcr.io": "gcloud",
"africa-south1-docker.pkg.dev": "gcloud",
"asia-docker.pkg.dev": "gcloud",
"asia-east1-docker.pkg.dev": "gcloud",
"asia-east2-docker.pkg.dev": "gcloud",
"asia-northeast1-docker.pkg.dev": "gcloud",
"asia-northeast2-docker.pkg.dev": "gcloud",
"asia-northeast3-docker.pkg.dev": "gcloud",
"asia-south1-docker.pkg.dev": "gcloud",
"asia-south2-docker.pkg.dev": "gcloud",
"asia-southeast1-docker.pkg.dev": "gcloud",
"asia-southeast2-docker.pkg.dev": "gcloud",
"australia-southeast1-docker.pkg.dev": "gcloud",
"australia-southeast2-docker.pkg.dev": "gcloud",
"docker.europe-west3.rep.pkg.dev": "gcloud",
"docker.europe-west8.rep.pkg.dev": "gcloud",
"docker.europe-west9.rep.pkg.dev": "gcloud",
"docker.me-central2.rep.pkg.dev": "gcloud",
"docker.us-central1.rep.pkg.dev": "gcloud",
"docker.us-central2.rep.pkg.dev": "gcloud",
"docker.us-east1.rep.pkg.dev": "gcloud",
"docker.us-east4.rep.pkg.dev": "gcloud",
"docker.us-east5.rep.pkg.dev": "gcloud",
"docker.us-east7.rep.pkg.dev": "gcloud",
"docker.us-south1.rep.pkg.dev": "gcloud",
"docker.us-west1.rep.pkg.dev": "gcloud",
"docker.us-west2.rep.pkg.dev": "gcloud",
"docker.us-west3.rep.pkg.dev": "gcloud",
"docker.us-west4.rep.pkg.dev": "gcloud",
"europe-central2-docker.pkg.dev": "gcloud",
"europe-docker.pkg.dev": "gcloud",
"europe-north1-docker.pkg.dev": "gcloud",
"europe-north2-docker.pkg.dev": "gcloud",
"europe-southwest1-docker.pkg.dev": "gcloud",
"europe-west1-docker.pkg.dev": "gcloud",
"europe-west10-docker.pkg.dev": "gcloud",
"europe-west12-docker.pkg.dev": "gcloud",
"europe-west2-docker.pkg.dev": "gcloud",
"europe-west3-docker.pkg.dev": "gcloud",
"europe-west4-docker.pkg.dev": "gcloud",
"europe-west6-docker.pkg.dev": "gcloud",
"europe-west8-docker.pkg.dev": "gcloud",
"europe-west9-docker.pkg.dev": "gcloud",
"me-central1-docker.pkg.dev": "gcloud",
"me-central2-docker.pkg.dev": "gcloud",
"me-west1-docker.pkg.dev": "gcloud",
"northamerica-northeast1-docker.pkg.dev": "gcloud",
"northamerica-northeast2-docker.pkg.dev": "gcloud",
"northamerica-south1-docker.pkg.dev": "gcloud",
"southamerica-east1-docker.pkg.dev": "gcloud",
"southamerica-west1-docker.pkg.dev": "gcloud",
"us-central1-docker.pkg.dev": "gcloud",
"us-central2-docker.pkg.dev": "gcloud",
"us-docker.pkg.dev": "gcloud",
"us-east1-docker.pkg.dev": "gcloud",
"us-east4-docker.pkg.dev": "gcloud",
"us-east5-docker.pkg.dev": "gcloud",
"us-east7-docker.pkg.dev": "gcloud",
"us-south1-docker.pkg.dev": "gcloud",
"us-west1-docker.pkg.dev": "gcloud",
"us-west2-docker.pkg.dev": "gcloud",
"us-west3-docker.pkg.dev": "gcloud",
"us-west4-docker.pkg.dev": "gcloud",
"us-west8-docker.pkg.dev": "gcloud"
}
}
Adding credentials for: us-east1-docker.pkg.dev
gcloud credential helpers already registered correctly.
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker tag valkyrie-prod us-east1-docker.pkg.dev/qwiklabs-gcp-01-cf31b282965f/valkyrie-repository/valkyrie-prod:v0.0.3
Error response from daemon: No such image: valkyrie-prod:latest
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker tag valkyrie-prod:v0.0.3 us-east1-docker.pkg.dev/qwikla
bs-gcp-01-cf31b282965f/valkyrie-repository/valkyrie-prod:v0.0.3
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
valkyrie-prod v0.0.3 f4b3cf5519d6 14 minutes ago 769MB
us-east1-docker.pkg.dev/qwiklabs-gcp-01-cf31b282965f/valkyrie-repository/valkyrie-prod v0.0.3 f4b3cf5519d6 14 minutes ago 769MB
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ ls
Jenkinsfile k8s source
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ docker push us-east1-docker.pkg.dev/qwiklabs-gcp-01-cf31b282965f/valkyrie-repository/valkyrie-prod:v0.0.3
The push refers to repository [us-east1-docker.pkg.dev/qwiklabs-gcp-01-cf31b282965f/valkyrie-repository/valkyrie-prod]
c41bfbd76b04: Pushed
e5b6cbf86fa4: Pushed
9e4b93e565c5: Pushed
7b9a9415bf3a: Pushed
facf15440126: Pushed
77b4b6493272: Pushed
6257fa9f9597: Pushed
578414b395b9: Pushed
abc3250a6c7f: Pushed
13d5529fd232: Pushed
v0.0.3: digest: sha256:c4019fbb5bd13b0635197f770539338a777a24a6b67469a3f12c93007a74f61a size: 2423
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ gcloud container clusters get-credentials valkyrie-dev --zone us-east1-c --project qwiklabs-gcp-01-cf31b282965f
kind: Deployment
apiVersion: apps/v1
metadata:
name: valkyrie-dev
spec:
replicas: 1
selector:
matchLabels:
app: valkyrie-app
template:
metadata:
name: valkyrie-app
labels:
app: valkyrie-app
9e4b93e565c5: Pushed
7b9a9415bf3a: Pushed
facf15440126: Pushed
77b4b6493272: Pushed
6257fa9f9597: Pushed
578414b395b9: Pushed
abc3250a6c7f: Pushed
13d5529fd232: Pushed
v0.0.3: digest: sha256:c4019fbb5bd13b0635197f770539338a777a24a6b67469a3f12c93007a74f61a size: 2423
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ gcloud container clusters get-credentials valkyrie-dev --zone us-east1-c --project qwiklabs-gcp-01-cf31b282965f
Fetching cluster endpoint and auth data.
kubeconfig entry generated for valkyrie-dev.
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ ls
Jenkinsfile k8s source
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app (qwiklabs-gcp-01-cf31b282965f)$ cd k8s/
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$ ls
deployment.yaml service.yaml
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$ cp deployment.yaml deployment.yaml.bak
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$ vim deployment.yaml
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$ ls
deployment.yaml deployment.yaml.bak service.yaml

student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$ vim service.yaml
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$ kubectl apply -f deployment.yaml
deployment.apps/valkyrie-dev created
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$ kubectl apply -f service.yaml
service/valkyrie-dev created
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$ kubectl get svc
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
kubernetes ClusterIP 34.118.224.1 <none> 443/TCP 92m
valkyrie-dev LoadBalancer 34.118.225.174 <pending> 80:31311/TCP 25s
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$ kubectl get svc
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
kubernetes ClusterIP 34.118.224.1 <none> 443/TCP 92m
valkyrie-dev LoadBalancer 34.118.225.174 <pending> 80:31311/TCP 28s
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$ kubectl get deployment
NAME READY UP-TO-DATE AVAILABLE AGE
valkyrie-dev 1/1 1 1 46s
student_00_aafcd0891006@cloudshell:~/marking/valkyrie-app/k8s (qwiklabs-gcp-01-cf31b282965f)$
